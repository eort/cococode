# created by Eduard Ort, 2019 

#######################
###  import libraries  ###
#######################
from psychopy import visual, core, event,gui,logging,data #import some libraries from PsychoPy
import expTools as et # custom scripts
import json # to load configuration files
import sys, os # to interact with the operating system
from datetime import datetime # to get the current time
import numpy as np # to do fancy math shit
import glob # to search in system efficiently
from IPython import embed as shell # for debugging

# reset all triggers to zero
os.system("/usr/local/bin/parashell 0x378 0")
#######################################
###  load config file (settings)  #####
#######################################
try:
    jsonfile = sys.argv[1]
except IndexError as e:
    print("No config file provided. Load default settings")
    jsonfile = 'default_cfg.json'
with open(jsonfile) as f:    
    param = json.load(f)

###########################################
###  Create Parameters / do Overhead   ####
###########################################
# read out json sidecar
n_trials = param['n_trials']            # number trials per block
n_blocks = param['n_blocks']            # number total blocks
fix_sleep_mean = param['fix_mean']      # presentation duration of fixdot
fix_sleep_range = param['fix_range']    # presentation duration of fixdot
feed_sleep = param['feed_sleep']        # presentation duration of feedback
practice = param['practice']            # are we practicing or not
trigger = param['trigger']              # trigger for defined events
rdk = param['cloud_specs']              # info on RDK


# dialog with participants: Retrieve Subject number, session number, and practice
input_dict = dict(sub_id=0,sess_id=0,practice=practice)
inputGUI =gui.DlgFromDict(input_dict,title='Experiment Info',order=['sub_id','sess_id','practice'])
# prepare the logfile and directories
et.prepDirectories()
logFile = os.path.join('log',param['logFile'].format(input_dict['sub_id'],input_dict['sess_id'],datetime.now()).replace(' ','-').replace(':','-'))
lastLog = logging.LogFile(logFile, level=logging.INFO, filemode='w')

# when did experiment start (GREEGO: start experiment time was before dialog)
start_exp_time = core.getTime()

###########################################
###  Create Experimental Sequence      ####
###########################################

# init logger
# update the constant values (things that wont change)
trial_info = { "sub_id":input_dict['sub_id'],
                "sess_id":input_dict['sess_id'],
                "start_exp_time":start_exp_time,
                "block_on_trigger":trigger['block_on'],
                "block_off_trigger":trigger['block_off'],
                "trial_on_trigger":trigger['trial_on'],
                "trial_off_trigger":trigger['trial_off'],
                "greeble_off_trigger":trigger['stim_off'],
                "timeout_on_on_trigger":trigger['timeout_on'],
                "timeout_off_trigger":trigger['timeout_off'],
                "resp_left_trigger":trigger['resp_left'],
                "resp_right_trigger":trigger['resp_right'],
                "coh_180_1_trigger":trigger["coh_180_1"],
                "coh_180_2_trigger":trigger["coh_180_2"],
                "coh_180_3_trigger":trigger["coh_180_3"],
                "coh_180_4_trigger":trigger["coh_180_4"],
                "coh_180_5_trigger":trigger["coh_180_5"],
                "coh_180_6_trigger":trigger["coh_180_6"],
                "coh_0_1_trigger":trigger["coh_0_1"],
                "coh_0_2_trigger":trigger["coh_0_2"],
                "coh_0_3_trigger":trigger["coh_0_3"],
                "coh_0_4_trigger":trigger["coh_0_4"],
                "coh_0_5_trigger":trigger["coh_0_5"],
                "coh_0_6_trigger":trigger["coh_0_6"],
                "end_block_time":np.nan}

for vari in param['logVars']:
    trial_info[vari] = param[vari]

# create a output file that collects all variables 
output_file = os.path.join('dat',param['expID'],param['output_file'].format(input_dict['sub_id'],input_dict['sess_id'],datetime.now()).replace(' ','-').replace(':','-'))
trial_info['logFile'] = logFile
trial_info['output_file'] = output_file

# prepare coherence levels of dots
coherence_lvls = param['coherence_lvl']   
n_cohs = len(coherence_lvls)
exp_frames = round(param['stim_sleep']*param['framerate'])

if param['mode'] == 'meg':
    resp_left = param['resp1_button']
    resp_right = param['resp2_button']
else:
    resp_left = param['resp1_key']
    resp_right = param['resp2_key']
################################
###  START ACTUAL EXPERIMENT ###
################################

#create a window
win = visual.Window(size=param['win_size'],color=param['bg_color'],fullscr=trial_info['fullscreen'],monitor="testMonitor", units="pix",screen=1)
# set Mouse to be invisible
event.Mouse(win=None,visible=False)
#########################
###  prepare stimuli  ###
#########################

# first all kind of structural messages
startBlock = visual.TextStim(win,text=param["blockStart"],color='white',wrapWidth=win.size[0])
endBlock = visual.TextStim(win,text=param["blockEnd"],color='white',wrapWidth=win.size[0])
endExp = visual.TextStim(win,text=param["exp_outro"],color='white',wrapWidth=win.size[0])
fixDot = et.fancyFixDot(win, fg_color = param['fg_color'],bg_color = param['bg_color']) # fixation dot
cloud = visual.DotStim(win,units = 'pix',fieldSize=rdk['cloud_size'],nDots=rdk['n_dots'],dotLife=rdk['dotLife'] ,dotSize=rdk['size_dots'],speed=rdk['speed'],signalDots=rdk['signalDots'],noiseDots=rdk['noiseDots'],fieldShape = 'circle')
timeout_scr = visual.TextStim(win,text='Zu langsam!',color='white',wrapWidth=win.size[0])
     
###########################
###  START BLOCK LOOP # ###
###########################

for block_no in range(n_blocks):
    # create trial sequence
    trial_seq = np.tile(np.arange(n_cohs),int(n_trials/n_cohs) )
    # make sure no direction repetitions of coherence levels
    np.random.shuffle(trial_seq)
    if not practice:    
        while 0 in np.diff(trial_seq):
            np.random.shuffle(trial_seq)

    # make sure every coherence lvl is matched with both directions equal number of times
    dir_list = [0,1]*int(n_trials/2/n_cohs)
    dir_dict = {}
    for coh in range(n_cohs):
        np.random.shuffle(dir_list)
        dir_dict[coh] =list(dir_list)

    # define direction sequence
    _dir_seq = []
    for coh in trial_seq:
        _dir_seq.append(dir_dict[coh].pop())

    dir_seq = [param['dir1'] if i==0 else param['dir2']  for i in _dir_seq ]
    corr_resp_seq = [resp_left if i==0 else resp_right  for i in _dir_seq]
    coh_seq = [coherence_lvls[i] for i in trial_seq ]
    
    # reset block variables
    trial_info['total_correct'] = 0 
   
    # show block intro
    startBlock.text = param["blockStart"].format(block_no+1)
    startBlock.draw()

    # show and wait for response
    win.flip()
    # wait for button press
    if param['mode'] != 'dummy':
        event.waitKeys(keyList = ['space'])
    # time when block started
    trial_info['start_block_time'] = core.getTime()
    trial_info['block_no']=block_no+1

    # send trigger
    et.sendTriggers(trigger['block_on'],mode=param['mode'])

    ##########################
    ###  START TRIAL LOOP  ###
    ##########################

    for trial_no in range(n_trials):

        # force quite experiment
        escape = event.getKeys()
        if 'q' in escape:
            et.finishExperiment(win,data_logger)

        trial_info['trial_no'] = trial_no+1
        trial_info['trial_count']+=1

        trial_info['respDur_resp'] = np.nan
        trial_info['respDur_noresp'] = np.nan
        trial_info['stimDur_noresp']= np.nan
        trial_info['stimDur_resp']= np.nan
        trial_info['feedbackDur']= np.nan
        trial_info['fixDur']= np.nan
        # jitter the fix duration
        trial_info['fix_sleep'] = np.random.uniform(fix_sleep_mean-fix_sleep_range,fix_sleep_mean+fix_sleep_range)

        # set specific orientations
        trial_info['corr_resp'] = corr_resp_seq[trial_no]
        trial_info['cur_dir'] = dir_seq[trial_no]
        trial_info['cur_coherence'] = coh_seq[trial_no]     

        # draw RDK stimulus
        cloud.coherence = trial_info['cur_coherence']
        cloud.dir = trial_info['cur_dir']

        trial_info['start_trial_time'] = core.getTime()
        t0 = core.getTime()
        # draw fixation and wait for 
        for elem in fixDot:
            elem.draw()        
        win.flip()
        # send triggers
        et.sendTriggers(trigger['trial_on'],mode=param['mode'])
        core.wait(trial_info['fix_sleep']-0.02*int(param['mode']=='meg'))

        # start response time measure
        trial_info['start_stim_time']  = core.getTime()
        # send triggers
        et.sendTriggers(trigger['coh_{}_{}'.format(param['dir1'],coherence_lvls.index(cloud.coherence)+1)],mode=param['mode'])
        
        timeout = 0.002
        t1 = core.getTime()
        for frame in range(exp_frames):
            for elem in fixDot:
                elem.draw()      
            cloud.draw()
            win.flip()
            # get response
            response = et.captureResponse(mode=param['mode'],key=[resp_left,resp_right],timeout= timeout)

            if response in [resp_left,resp_right]:
                t2 = core.getTime()
                trial_info['stimDur_resp'] = t2-t1
                core.wait(0.01) # sleep to make responses not overlap with following stim
                break

        
        
        # remove stimulus        
        for elem in fixDot:
            elem.draw()  
        win.flip()
        # end times of stimulation
        trial_info['end_stim_time'] = core.getTime()
        # send triggers
        et.sendTriggers(trigger['stim_off'],mode=param['mode'])
        
        if response !=None:
            t3 = core.getTime()
            trial_info['stimDur_noresp'] = t3-t1
            # start response time measure
            timeout = param['resp_sleep']-0.02*int(param['mode']=='meg')
            while True:
                response = et.captureResponse(mode=param['mode'],key=[resp_left,resp_right],timeout= timeout)
                if response in [resp_left,resp_right]:
                    t4 = core.getTime()
                    trial_info['respDur_resp'] = t4-t3                    
                    core.wait(0.01) # sleep to make responses not overlap with following stim
                    break

                if core.getTime()-trial_info['start_stim_time']>param['resp_sleep']:
                    # define nogo response variables
                    response = None
                    t4 = core.getTime()
                    trial_info['respDur_noresp'] = t4-t3
                    break

        ##########################
        ###  POST PROCESSING   ###
        ##########################
        # start handling response variables
        trial_info['resp_time'] = core.getTime()-trial_info['start_stim_time']
        trial_info['resp_key'] = response
        trial_info['correct'] = response==trial_info['corr_resp']      
        
        if response != None:
            trial_info['timeout'] = 0
        else:
            t6 = core.getTime()
            trial_info['timeout'] = 1
            timeout_scr.draw()
            win.flip()
            et.sendTriggers(trigger['timeout_on'],mode=param['mode'])
            core.wait(param['feed_sleep']-0.02*int(param['mode']=='meg'))
            win.flip()
            t7 = core.getTime()
            et.sendTriggers(trigger['timeout_off'],mode=param['mode'])

        # show trial feedback
        if trial_info['correct']:
            trial_info['total_correct']+=1
        trial_info['fixDur'] = t1-t0      
        trial_info['feedbackDur'] = (t7-t6)
        # send triggers
        trial_info['end_trial_time'] = core.getTime()
        et.sendTriggers(trigger['trial_off'],mode=param['mode'])
        # logging
        if trial_info['trial_count'] == 1:
            data_logger = et.Logger(outpath=output_file,nameDict = trial_info)
        data_logger.writeTrial(trial_info)

    # end of block message
    trial_info['end_prev_block_time'] = core.getTime()
    # send triggers
    et.sendTriggers(trigger['block_off'],mode=param['mode'])

    # show text at the end of a block        
    endBlock.text = param["blockEnd"].format(block_no+1,int(100*trial_info['total_correct']/n_trials))
    endBlock.draw()
    win.flip()
    if param['mode'] != 'dummy':
        event.waitKeys(keyList = ['space'])      

# end of experiment message
endExp.draw()
win.flip()
if param['mode'] != 'dummy':
    event.waitKeys(keyList = ['space'])    

#cleanup
et.finishExperiment(win,data_logger,show_results=True)